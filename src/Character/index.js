/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import { useEffect, useLayoutEffect, useRef, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { MeshBVH, MeshBVHVisualizer } from "three-mesh-bvh";
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';
import { useFrame, useThree } from "@react-three/fiber";
import { Quaternion, Vector3 } from "three";
// import { useCompoundBody} from "@react-three/cannon";
import { useStore } from "../store";

const keys = {
  KeyW: "forward",
  KeyS: "backward",
  KeyA: "left",
  KeyD: "right",
  Space: "jump",
};
const moveFieldByKey = (key) => keys[key];

// temporary data
const walkDirection = new Vector3();
const rotateAngle = new Vector3(0, 1, 0);
const rotateQuarternion = new Quaternion();
const cameraTarget = new Vector3();
let player, controls;
let playerVelocity = new THREE.Vector3();
let upVector = new THREE.Vector3(0, 1, 0);
let tempVector = new THREE.Vector3();
let playerIsOnGround = false;
let tempVector2 = new THREE.Vector3();
let tempBox = new THREE.Box3();
let tempMat = new THREE.Matrix4();
let tempSegment = new THREE.Line3();


const walkVelocity = 2;
const compoundStructure = [
  {
    position: [0, 0, 0],
    args: [0.5, 0.4, 0.1],
  },
  {
    position: [0, 0.25, 0],
    args: [0.5, 0.4, 0.1],
  },
  {
    position: [0, 0.5, 0],
    args: [0.5, 0.4, 0.1],
  },
];
let colliderGroup = new THREE.Object3D();


export default function Soldier({ pose, ...props }) {
  const model = useRef();
  const collision = useRef();

  THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
  THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
  THREE.Mesh.prototype.raycast = acceleratedRaycast;

  const { nodes, materials, animations } = useGLTF("/models/Soldier.glb");


  const { actions, names } = useAnimations(animations, model);
  const [index, setIndex] = useState(pose);
  const [init, setInit] = useState(true);
  const [toggleRun, setToggleRun] = useState(false);
  const runVelocity = useStore((state) => state.runVelocity);
  const { camera } = useThree();
  function switchRunToggle() {
    setToggleRun(!toggleRun);
  }

  function updateCameraTarget(moveX, moveZ) {
    // move camera
  }

  const usePlayerControls = () => {
    const [movement, setMovement] = useState({
      forward: false,
      backward: false,
      left: false,
      right: false,
      jump: false,
    });
    useEffect(() => {
      const handleKeyDown = (e) => {
        setIndex(1);
        setMovement((m) => {
          return { ...m, [moveFieldByKey(e.code)]: true };
        });
      };
      const handleKeyUp = (e) => {
        setMovement((m) => {
          return { ...m, [moveFieldByKey(e.code)]: false };
        });
        setToggleRun(false);
      };
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return movement;
  };

  useEffect(() => {
    const material = new THREE.MeshStandardMaterial();
    material.opacity = 0.0;
    material.transparent = true;
    material.depthWrite = false;
    player = new THREE.Mesh(
      new RoundedBoxGeometry(1.0, 2.0, 1.0, 10, 0.5),
      material
    );
    player.geometry.translate(0, 1.2, 0);
    player.capsuleInfo = {
      radius: 0.3,
      segment: new THREE.Line3(new THREE.Vector3(), new THREE.Vector3(0, - 0.1, 0.0))
    };
    player.castShadow = true;
    player.receiveShadow = true;
    player.material.shadowSide = 2;
    model.current.add(player);
  }, []);
  const { forward, backward, left, right, jump } = usePlayerControls();
  useLayoutEffect(() => {
    // Reset and fade in animation after an index has been changed
    actions[names[index]].reset().fadeIn(0.5).play();
    // In the clean-up phase, fade it out
    return () => actions[names[index]].fadeOut(0.5);
    // actions[names[index]].play()
  }, [index, actions, names, pose, toggleRun]);
  function updatePlayer(delta) {
    playerVelocity.y += playerIsOnGround ? 0 : -12;
    model.current.position.addScaledVector(playerVelocity, delta);
    if (names[index] == "Run" || names[index] == "Walk") {
      // move the player
      let angleYCameraDirection = Math.atan2(
        camera.position.x - model.current.position.x,
        camera.position.z - model.current.position.z
      );
      let directionOffset = getDirectionOffset(forward, backward, right, left);
      rotateQuarternion.setFromAxisAngle(
        rotateAngle,
        angleYCameraDirection + directionOffset
      );
      model.current.quaternion.rotateTowards(rotateQuarternion, 0.2);
      camera.getWorldDirection(walkDirection);
      walkDirection.y = 0;
      walkDirection.normalize();
      walkDirection.applyAxisAngle(rotateAngle, directionOffset);

      const velocity = runVelocity;

      if (forward) {
        tempVector.set(0, 0, - 1).applyAxisAngle(upVector, angleYCameraDirection);
        model.current.position.addScaledVector(tempVector, velocity/100);
      }

      if (backward) {
        tempVector.set(0, 0, 1).applyAxisAngle(upVector, angleYCameraDirection);
        model.current.position.addScaledVector(tempVector, velocity/100);
      }

      if (left) {
        tempVector.set(- 1, 0, 0).applyAxisAngle(upVector, angleYCameraDirection);
        model.current.position.addScaledVector(tempVector, velocity/100);
      }

      if (right) {
        tempVector.set(1, 0, 0).applyAxisAngle(upVector, angleYCameraDirection);
        model.current.position.addScaledVector(tempVector, velocity/100);
      }
      model.current.updateMatrixWorld();
    }

    // // adjust player position based on collisions
    const capsuleInfo = player.capsuleInfo;
    tempBox.makeEmpty();
    tempMat.copy(props.colliders.matrixWorld).invert();
    tempSegment.copy(capsuleInfo.segment);

    // get the position of the capsule in the local space of the collider
    tempSegment.start.applyMatrix4(model.current.matrixWorld).applyMatrix4(tempMat);
    tempSegment.end.applyMatrix4(model.current.matrixWorld).applyMatrix4(tempMat);

    // // get the axis aligned bounding box of the capsule
    tempBox.expandByPoint(tempSegment.start);
    tempBox.expandByPoint(tempSegment.end);

    tempBox.min.addScalar(- capsuleInfo.radius);
    tempBox.max.addScalar(capsuleInfo.radius);

    props.colliders.geometry.boundsTree.shapecast(null, {
      intersectsBounds: box => box.intersectsBox(tempBox),

      intersectsTriangle: tri => {

        // check if the triangle is intersecting the capsule and adjust the
        // capsule position if it is.
        const triPoint = tempVector;
        const capsulePoint = tempVector2;

        const distance = tri.closestPointToSegment(tempSegment, triPoint, capsulePoint);
        if (distance < capsuleInfo.radius) {

          const depth = capsuleInfo.radius - distance;
          const direction = capsulePoint.sub(triPoint).normalize();

          tempSegment.start.addScaledVector(direction, depth);
          tempSegment.end.addScaledVector(direction, depth);

        }


      }
    });

    // get the adjusted position of the capsule collider in world space after checking
    // triangle collisions and moving it. capsuleInfo.segment.start is assumed to be
    // the origin of the player model.
    const newPosition = tempVector;
    newPosition.copy(tempSegment.start).applyMatrix4(props.colliders.matrixWorld);

    // check how much the collider was moved
    const deltaVector = tempVector2;
    deltaVector.subVectors(newPosition, model.current.position);

    // if the player was primarily adjusted vertically we assume it's on something we should consider ground
    playerIsOnGround = deltaVector.y > Math.abs(delta * playerVelocity.y * 0.25);
    const offset = Math.max(0.0, deltaVector.length() - 1e-5);
    deltaVector.normalize().multiplyScalar(offset);
    console.log(playerVelocity.y)
    // adjust the player model
    model.current.position.add(deltaVector);

    if (!playerIsOnGround) {

      deltaVector.normalize();
      playerVelocity.addScaledVector(deltaVector, - deltaVector.dot(playerVelocity));

    } else {

      playerVelocity.set(0, 0, 0);

    }
  }
  useFrame((state) => {

    let delta = state.clock.getDelta();

    if (!forward && !backward && !left && !right) {
      setIndex(0)
    }

    camera.position.sub(state.controls.target);
    state.controls.target.copy(model.current.position);
    camera.position.add(model.current.position);
    if (props.colliders)
      updatePlayer(delta)

  });
  return (
    <>

      <group
        position={[0, -11, -8]}
        castShadow
        ref={model}
        {...props}
        dispose={null}
      >
        <group rotation={[-Math.PI / 2, 0, 0]} scale={[0.008, 0.008, 0.008]} position={[0, -0.4, 0]}>
          <primitive object={nodes.mixamorigHips} />
          <skinnedMesh
            wireframe
            geometry={nodes.vanguard_Mesh.geometry}
            material={materials.VanguardBodyMat}
            skeleton={nodes.vanguard_Mesh.skeleton}
          />
          <skinnedMesh
            geometry={nodes.vanguard_visor.geometry}
            material={materials.Vanguard_VisorMat}
            skeleton={nodes.vanguard_visor.skeleton}
          />


        </group>
      </group>
    </>
  );
}

function getDirectionOffset(w, s, d, a) {
  let directionOffset = 0; // w
  if (s) {
    if (a) {
      directionOffset = Math.PI / 4 + Math.PI / 2; // s+a
    } else if (d) {
      directionOffset = -Math.PI / 4 - Math.PI / 2; // s+d
    } else {
      directionOffset = Math.PI; // s
    }
  } else if (d) {
    directionOffset = -Math.PI / 2; // d
    if (d && w) {
      directionOffset = -Math.PI / 4; // w+a
    }
  }
  else if (a) {
    directionOffset = Math.PI / 2; // w+a
    if (a && w) {
      directionOffset = Math.PI / 4; // w+a
    }
  }


  return directionOffset;
}

